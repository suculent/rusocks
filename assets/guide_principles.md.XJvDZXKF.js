import{_ as t,a as r}from"./chunks/reverse_proxy_diagram.wO_OGZ4h.js";import{_ as o,c as a,o as n,ae as s}from"./chunks/framework.U1Gow_7P.js";const b=JSON.parse('{"title":"How It Works","description":"","frontmatter":{},"headers":[],"relativePath":"guide/principles.md","filePath":"guide/principles.md"}'),i={name:"guide/principles.md"};function l(c,e,d,p,h,u){return n(),a("div",null,e[0]||(e[0]=[s('<h1 id="how-it-works" tabindex="-1">How It Works <a class="header-anchor" href="#how-it-works" aria-label="Permalink to &quot;How It Works&quot;">​</a></h1><p>LinkSocks operates in two main proxy modes, each designed for different network scenarios.</p><h2 id="forward-proxy" tabindex="-1">Forward Proxy <a class="header-anchor" href="#forward-proxy" aria-label="Permalink to &quot;Forward Proxy&quot;">​</a></h2><p>Forward proxy allows a server to expose its internal network environment while protecting its IP address from being exposed.</p><p>First, start a LinkSocks server on a machine that can host websites and be accessed from the public internet, and add a token.</p><p>Then, on the device that needs to access the server&#39;s internal network environment, start the LinkSocks client and connect to the designated URL using the token. Since the transmission uses the WebSocket protocol, any WebSocket-supporting web firewall such as Cloudflare can be used as an intermediary layer to protect the server&#39;s IP address from being exposed.</p><p>After connecting, the client will open a configurable SOCKS5 port for other services to connect to. All requests will be forwarded through the established bidirectional channel, with the server performing the actual connections and sending data.</p><p><img src="'+t+'" alt="Forward Proxy Diagram"></p><h3 id="forward-proxy-use-cases" tabindex="-1">Forward Proxy Use Cases <a class="header-anchor" href="#forward-proxy-use-cases" aria-label="Permalink to &quot;Forward Proxy Use Cases&quot;">​</a></h3><ul><li><strong>Accessing restricted networks</strong>: Connect to internal services through a central server</li><li><strong>IP protection</strong>: Hide your real IP when making requests</li><li><strong>Bypassing firewalls</strong>: Use WebSocket transport to bypass traditional firewall restrictions</li></ul><h2 id="reverse-proxy" tabindex="-1">Reverse Proxy <a class="header-anchor" href="#reverse-proxy" aria-label="Permalink to &quot;Reverse Proxy&quot;">​</a></h2><p>Reverse proxy allows devices, which cannot be directly accessed from the public internet, to expose their internal network environment.</p><p>First, start a LinkSocks server on a machine that can host websites and be accessed from the public internet, and add a token.</p><p>Then, start a LinkSocks client on the internal network server and connect to the designated URL using the token. Since the transmission uses the WebSocket protocol, any WebSocket-supporting web firewall such as Cloudflare can be used as an intermediary layer to protect the server&#39;s IP from being exposed.</p><p>After connecting, the server will expose a SOCKS5 port for other services to connect to. All requests will be forwarded through the established bidirectional channel, with the client performing the actual connections and sending data.</p><p><img src="'+r+'" alt="Reverse Proxy Diagram"></p><h3 id="reverse-proxy-use-cases" tabindex="-1">Reverse Proxy Use Cases <a class="header-anchor" href="#reverse-proxy-use-cases" aria-label="Permalink to &quot;Reverse Proxy Use Cases&quot;">​</a></h3><ul><li><strong>Internal network access</strong>: Access services on machines without public IP addresses</li><li><strong>Load balancing</strong>: Multiple clients can provide network access with automatic load balancing</li><li><strong>CAPTCHA solving</strong>: Use diverse client networks for CAPTCHA solving and IP rotation</li><li><strong>Penetration testing</strong>: After compromising internal network servers, directly penetrate outward</li></ul><h2 id="technical-advantages" tabindex="-1">Technical Advantages <a class="header-anchor" href="#technical-advantages" aria-label="Permalink to &quot;Technical Advantages&quot;">​</a></h2><h3 id="websocket-transport" tabindex="-1">WebSocket Transport <a class="header-anchor" href="#websocket-transport" aria-label="Permalink to &quot;WebSocket Transport&quot;">​</a></h3><ul><li><strong>Firewall friendly</strong>: WebSocket traffic appears as normal HTTP traffic</li><li><strong>WAF compatible</strong>: Works through Web Application Firewalls like Cloudflare</li><li><strong>CDN support</strong>: Can be deployed behind CDNs for enhanced security</li><li><strong>SSL/TLS support</strong>: Secure transmission with WSS protocol</li></ul><h3 id="dynamic-client-management" tabindex="-1">Dynamic Client Management <a class="header-anchor" href="#dynamic-client-management" aria-label="Permalink to &quot;Dynamic Client Management&quot;">​</a></h3><ul><li><strong>No configuration required</strong>: Clients can join and leave without server reconfiguration</li><li><strong>Automatic scaling</strong>: System scales based on available client capacity</li><li><strong>Load balancing</strong>: Round-robin distribution across available clients</li><li><strong>Fault tolerance</strong>: Automatic failover when clients disconnect</li></ul><h3 id="protocol-support" tabindex="-1">Protocol Support <a class="header-anchor" href="#protocol-support" aria-label="Permalink to &quot;Protocol Support&quot;">​</a></h3><ul><li><strong>Full SOCKS5</strong>: Complete SOCKS5 protocol implementation</li><li><strong>Authentication</strong>: Token-based authentication for secure connections</li><li><strong>IPv6 support</strong>: Full IPv6 connectivity support</li><li><strong>UDP support</strong>: UDP over SOCKS5 for comprehensive protocol coverage</li></ul>',25)]))}const f=o(i,[["render",l]]);export{b as __pageData,f as default};
